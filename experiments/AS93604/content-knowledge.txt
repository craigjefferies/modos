# Scholarship Digital Technologies (93604)  
## Content Knowledge Guide (Student Version, 2025)

---

## ğŸ¯ What This Exam Assesses  
- You will answer **three main questions** that test:  
  1. **Algorithmic Comprehension & Decomposition** â€“ reading, understanding, breaking down algorithms  
  2. **Algorithm Development & Implementation** â€“ designing and writing solutions  
  3. **Critical Reflection & Analysis** â€“ comparing, improving, justifying your choices  

- Expect **large input sizes**, **time & memory constraints**, and **restrictions on shortcuts** (e.g. no built-in `reverse()`, `sort()` in improve tasks) :contentReference[oaicite:1]{index=1}  
- Answers should be in **pseudocode** (language-agnostic) and include comments, clarity, and justification  
- You will likely receive a **reference sheet** during the exam :contentReference[oaicite:2]{index=2}  

---

## ğŸ§© Core Abilities to Demonstrate  

| Domain | You Should Be Able To Do |
|---|---|
| **Algorithmic Thinking** | Trace pseudocode; identify loops, conditions, recursion; deduce output; detect inefficiency |
| **Algorithm Development** | Choose suitable data structures; write clear, modular pseudocode; ensure correctness |
| **Evaluation & Reflection** | Analyze time/space complexity; compare alternatives; test boundary cases; justify choices |
| **Communication** | Use clear naming; comment logic; structure answers; explain reasoning and tradeoffs |

---

## ğŸ”¢ Key Algorithmic Patterns & Techniques  

- **Sliding Window / Two-Pointer / Prefix Sums** â€” for contiguous subarray / substring problems  
- **Divide & Conquer / Recursion** â€” e.g. merge sort, quicksort; recursive decomposition  
- **Sorting & Searching** â€” merge sort, quicksort, binary search, possibly heap sort  
- **Graph & Pathfinding** â€” BFS, DFS, Dijkstra (if weights are nonnegative), perhaps A* if context allows  
- **Dynamic Programming** â€” define state, transition, bottom-up / top-down, rolling arrays  
- **Greedy & Selection** â€” sort + greedy choice, priority queues, proofs or counterexamples  
- **String / Sequence Algorithms** â€” palindrome check with two pointers, substring matching, rolling hash  

---

## ğŸ§° Common Data Structures  

- **Array / List** â€” ordered collection, direct indexing  
- **Stack / Queue** â€” LIFO or FIFO usage  
- **Hash Map / Set** â€” fast key lookup, membership testing  
- **Heap / Priority Queue** â€” dynamic selection of min / max  
- **Graph / Tree structures** â€” adjacency list / matrix, parent/child relationships  

---

## ğŸ” Evaluation & Improvement: What to Always Include  

- **Correctness** â€” handle all test cases, including edge or boundary cases  
- **Efficiency** â€” state time (O-notation) and space complexities, and find bottlenecks  
- **Trade-offs & Alternatives** â€” explain why one method was chosen over another  
- **Scalability** â€” discuss behavior as data size increases  
- **Testing** â€” sample, worst-case, boundary input tests  
- **Reflection** â€” note what was improved, limitations, and possible further optimisations  

---

## ğŸ§  THINK â†’ MAKE â†’ REFLECT (in practice)  

- **THINK**: Decompose the problem; identify subproblems; plan approach  
- **MAKE**: Write pseudocode, modular with named subroutines; maintain clarity  
- **REFLECT**: Test your solution; analyze complexity; explain choices; suggest improvements  

---

## ğŸ“˜ Types of Questions Youâ€™ll Encounter  

| Question Type | Goal |
|---------------|------|
| **Comprehension & Decomposition** | â€œExplain what this pseudocode does and decompose into subroutines.â€ |
| **Critique / Improve Given Algorithm** | â€œIdentify inefficiencies or boundary flaws, and propose a better version.â€ |
| **Algorithm Design** | â€œDesign an algorithm to solve this problem under constraints.â€ |
| **Evaluation / Comparison** | â€œCompare two methods, state pros/cons, and explain which is superior and why.â€ |
| **Scaling / Variant Adaptation** | â€œHow would your algorithm change if input is 10Ã— larger or constraints shift?â€ |

---

## ğŸ› ï¸ How to Prepare Effectively  

1. Trace and explain existing pseudocode line-by-line  
2. Practice writing modular, clean pseudocode under time pressure  
3. Solve many â€œlarge input / constrainedâ€ problems (sliding window, knapsack, string matching)  
4. After solving, write a short analysis: correctness, complexity, alternative methods  
5. Study sample assessments and exemplars; annotate how top responses are structured  
6. Maintain a personal â€œpitfall logâ€ (bugs, off-by-one, hidden cost) and how you fixed them  
7. Practice short critique tasks (given flawed algorithm, find improvements)  

---

## ğŸ Exam Tips & Reminders  

- Clarity over cleverness â€” use straightforward, understandable logic  
- Always include a short reasoning or proof of correctness  
- State complexity (time & space) and justify it  
- Explicitly mention what edge cases you considered  
- When comparing methods, structure your answer: description, complexity, pros/cons, decision  
- Use diagrams, sample inputs or tables if they help your explanation  

---

