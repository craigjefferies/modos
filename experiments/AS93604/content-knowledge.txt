# Scholarship Digital Technologies (93604)
### Content Knowledge Guide â€“ Student Version (2025, v2)

---

## ğŸ¯ What This Exam Is About
The Scholarship Digital Technologies exam tests how well you can **think, design, and reflect** like a computer scientist â€” understanding, building, and improving algorithms to solve complex problems.

Youâ€™ll answer **three main questions** that assess:
1. **Algorithmic Comprehension and Decomposition** â€“ understanding and explaining algorithms.
2. **Algorithm Development and Implementation** â€“ designing and coding solutions.
3. **Critical Reflection and Analysis** â€“ testing, comparing, and improving your work.

Questions can come from any **Level 8 topic** in:
- *Computational Thinking for Digital Technologies*
- *Designing and Developing Digital Outcomes*

---

## ğŸ’¡ What Scholarship Answers Show
Scholarship isnâ€™t about memorising facts â€” itâ€™s about showing deeper thinking:
- **Insight** â€“ you can explain how and why something works.
- **Abstraction** â€“ you recognise general patterns and ideas.
- **Clarity** â€“ your code and explanations are logical and easy to follow.
- **Elegance** â€“ your solutions are tidy, efficient, and make sense.

---

## ğŸ§© Core Knowledge Youâ€™ll Need

| Focus Area | What You Should Know | Example Skills |
|-------------|---------------------|----------------|
| **Algorithmic Thinking** | How algorithms are structured and explained. | Trace pseudocode; identify sequence, selection, and loops; use recursion or functions; **identify an algorithmâ€™s purpose and predict its output.** |
| **Algorithm Development** | How to design and build working solutions. | Pick good data structures (lists, arrays, graphs); code clear steps; test and debug logic. |
| **Evaluation & Reflection** | How to check and improve your design. | Compare methods; explain efficiency (speed and memory); **explain why one approach is preferable**; justify changes or trade-offs. |
| **Communication** | How to explain your ideas clearly. | Write neat pseudocode; use comments; describe choices and results clearly. |

---

## ğŸ”¢ Common Algorithm Patterns
- **Sorting & Searching:** bubble, selection, merge, quicksort, binary search.  
- **Graph & Pathfinding:** BFS, DFS, Dijkstra, A*.  
- **Recursion:** solving smaller subproblems within the same algorithm.  
- **Dynamic Programming:** saving results to avoid repeat work (e.g., Fibonacci).  
- **Greedy Algorithms:** picking the best option at each step (e.g., coin change).  
- **Search and Optimisation:** applying BFS, DFS, or DP to find the best or shortest solution under constraints.  

---

## ğŸ§® Data and Structures
Know how and when to use:
- **Arrays/Lists:** store ordered data.
- **Stacks/Queues:** handle â€œfirst in, first outâ€ or â€œlast in, first out.â€
- **Graphs/Trees:** model relationships and paths.
- **Maps/Dictionaries:** store keyâ€“value pairs.

---

## ğŸ” Evaluating and Improving

| Area | What You Need to Do |
|------|---------------------|
| **Correctness** | Show your algorithm works for all test cases. |
| **Efficiency** | Explain how fast or memory-heavy it is. Use simple examples like: â€œA loop that checks every letter takes one step per character.â€ |
| **Trade-offs** | Explain why you chose one method over another (e.g., BFS vs A*). |
| **Scalability** | How would your solution change for bigger data? |
| **Testing** | Create and record test cases, fix logic errors. |
| **Reflection** | Explain what improved and what you learned. |

---

## ğŸ§  THINK â†’ MAKE â†’ REFLECT
Understand Build Test & Explain

- **THINK:** Break down the problem and plan your steps.  
- **MAKE:** Write pseudocode or code that is correct and readable.  
- **REFLECT:** Test, spot weaknesses, and explain your improvements.

---

- **THINK:** Break down the problem, identify its purpose, and plan your steps.  
- **MAKE:** Write pseudocode or code that is correct and readable.  
- **REFLECT:** Test, spot weaknesses, and explain your improvements.

---

## ğŸ“˜ Example Question Types

| Type | Example |
|------|----------|
| Algorithmic Comprehension | â€œExplain what this pseudocode does and find one inefficiency.â€ |
| Algorithm Development | â€œDesign an algorithm to find the shortest route between cities.â€ |
| Critical Reflection | â€œCompare two methods and justify which is more efficient or simpler.â€ |
| Combined Insight | â€œHow would your algorithm change if the dataset was 10Ã— larger?â€ |

---

## ğŸ§° How to Prepare
1. Practise tracing code and explaining each line.  
2. Write **pseudocode** that anyone can follow.  
3. Design and test your own algorithms.  
4. Compare different approaches and explain your choices.  
5. Keep a record of bugs and how you fixed them.  
6. Discuss ethical or real-world effects of your solutions.  
7. Always explain your reasoning â€” donâ€™t just show code.

---

## ğŸ Final Tips
- Focus on **clarity before cleverness** â€“ make sure your logic is easy to follow.  
- Show evidence that you tested and improved your solution.  
- Use **examples, diagrams, or short tables** if they help explain your idea.  
- Replace technical terms like *Big-O* with everyday ideas like *growth rate* when writing explanations.  
- Remember: Scholarship is about **understanding and reflection**, not memorising code.
