# Scholarship Digital Technologies (93604)  
## Content Knowledge Guide (Student Version, 2025)

---

## 🎯 What This Exam Assesses  
- You will answer **three main questions** that test:  
  1. **Algorithmic Comprehension & Decomposition** – reading, understanding, breaking down algorithms  
  2. **Algorithm Development & Implementation** – designing and writing solutions  
  3. **Critical Reflection & Analysis** – comparing, improving, justifying your choices  

- Expect **large input sizes**, **time & memory constraints**, and **restrictions on shortcuts** (e.g. no built-in `reverse()`, `sort()` in improve tasks) :contentReference[oaicite:1]{index=1}  
- Answers should be in **pseudocode** (language-agnostic) and include comments, clarity, and justification  
- You will likely receive a **reference sheet** during the exam :contentReference[oaicite:2]{index=2}  

---

## 🧩 Core Abilities to Demonstrate  

| Domain | You Should Be Able To Do |
|---|---|
| **Algorithmic Thinking** | Trace pseudocode; identify loops, conditions, recursion; deduce output; detect inefficiency |
| **Algorithm Development** | Choose suitable data structures; write clear, modular pseudocode; ensure correctness |
| **Evaluation & Reflection** | Analyze time/space complexity; compare alternatives; test boundary cases; justify choices |
| **Communication** | Use clear naming; comment logic; structure answers; explain reasoning and tradeoffs |

---

## 🔢 Key Algorithmic Patterns & Techniques  

- **Sliding Window / Two-Pointer / Prefix Sums** — for contiguous subarray / substring problems  
- **Divide & Conquer / Recursion** — e.g. merge sort, quicksort; recursive decomposition  
- **Sorting & Searching** — merge sort, quicksort, binary search, possibly heap sort  
- **Graph & Pathfinding** — BFS, DFS, Dijkstra (if weights are nonnegative), perhaps A* if context allows  
- **Dynamic Programming** — define state, transition, bottom-up / top-down, rolling arrays  
- **Greedy & Selection** — sort + greedy choice, priority queues, proofs or counterexamples  
- **String / Sequence Algorithms** — palindrome check with two pointers, substring matching, rolling hash  

---

## 🧰 Common Data Structures  

- **Array / List** — ordered collection, direct indexing  
- **Stack / Queue** — LIFO or FIFO usage  
- **Hash Map / Set** — fast key lookup, membership testing  
- **Heap / Priority Queue** — dynamic selection of min / max  
- **Graph / Tree structures** — adjacency list / matrix, parent/child relationships  

---

## 🔍 Evaluation & Improvement: What to Always Include  

- **Correctness** — handle all test cases, including edge or boundary cases  
- **Efficiency** — state time (O-notation) and space complexities, and find bottlenecks  
- **Trade-offs & Alternatives** — explain why one method was chosen over another  
- **Scalability** — discuss behavior as data size increases  
- **Testing** — sample, worst-case, boundary input tests  
- **Reflection** — note what was improved, limitations, and possible further optimisations  

---

## 🧠 THINK → MAKE → REFLECT (in practice)  

- **THINK**: Decompose the problem; identify subproblems; plan approach  
- **MAKE**: Write pseudocode, modular with named subroutines; maintain clarity  
- **REFLECT**: Test your solution; analyze complexity; explain choices; suggest improvements  

---

## 📘 Types of Questions You’ll Encounter  

| Question Type | Goal |
|---------------|------|
| **Comprehension & Decomposition** | “Explain what this pseudocode does and decompose into subroutines.” |
| **Critique / Improve Given Algorithm** | “Identify inefficiencies or boundary flaws, and propose a better version.” |
| **Algorithm Design** | “Design an algorithm to solve this problem under constraints.” |
| **Evaluation / Comparison** | “Compare two methods, state pros/cons, and explain which is superior and why.” |
| **Scaling / Variant Adaptation** | “How would your algorithm change if input is 10× larger or constraints shift?” |

---

## 🛠️ How to Prepare Effectively  

1. Trace and explain existing pseudocode line-by-line  
2. Practice writing modular, clean pseudocode under time pressure  
3. Solve many “large input / constrained” problems (sliding window, knapsack, string matching)  
4. After solving, write a short analysis: correctness, complexity, alternative methods  
5. Study sample assessments and exemplars; annotate how top responses are structured  
6. Maintain a personal “pitfall log” (bugs, off-by-one, hidden cost) and how you fixed them  
7. Practice short critique tasks (given flawed algorithm, find improvements)  

---

## 🏁 Exam Tips & Reminders  

- Clarity over cleverness — use straightforward, understandable logic  
- Always include a short reasoning or proof of correctness  
- State complexity (time & space) and justify it  
- Explicitly mention what edge cases you considered  
- When comparing methods, structure your answer: description, complexity, pros/cons, decision  
- Use diagrams, sample inputs or tables if they help your explanation  

---

