{
  "meta": {
    "as_code": "93604",
    "title": "Scholarship Digital Technologies (93604) – OMIS Indicators",
    "version": "2025 OMIS v2",
    "assessment_type": "External",
    "purpose": "Indicators for algorithmic comprehension, development, reflection, and communication in Scholarship Digital Technologies"
  },
  "key_terms": [
    {
      "term": "Algorithmic comprehension & decomposition",
      "definition": "Understanding problem requirements, decomposing into subproblems, and explaining algorithm structure."
    },
    {
      "term": "Algorithm development & implementation",
      "definition": "Designing and coding solutions that satisfy constraints, are correct, efficient, and well structured."
    },
    {
      "term": "Critical reflection & analysis",
      "definition": "Evaluating correctness, efficiency, trade-offs, scalability, and suggesting refinements or alternatives."
    },
    {
      "term": "Communication & presentation",
      "definition": "Explaining design rationale, structure, and reasoning clearly and convincingly."
    }
  ],
  "omis": [
    {
      "id": "io_specification_identified",
      "dimension": "Algorithmic comprehension & decomposition",
      "description": "Explicitly identifies inputs, outputs, constraints (ranges, limits), and stopping conditions before algorithm design or modification.",
      "level": "A",
      "weight": 1,
      "detection_hint": "Look for formal variable names, domain/range specs, output description, termination condition. A mere restatement of the problem without these is insufficient.",
      "success_examples": [
        "“Input: N (1 ≤ N ≤ 10⁶). Output: minimal number of moves.”",
        "“Terminate when left > right; no built-in reverse allowed.”"
      ]
    },
    {
      "id": "control_structure_decomposition",
      "dimension": "Algorithmic comprehension & decomposition",
      "description": "Breaks the logic into explicit control structures (sequence, selection, iteration, recursion) with clear hierarchy.",
      "level": "A",
      "weight": 1,
      "detection_hint": "Must include IF / FOR / WHILE (or recursion) with proper indentation or end markers. A bullet outline without flow is weak.",
      "success_examples": [
        "“FOR i FROM 0 TO n-1 DO … ENDFOR”",
        "“IF a[i] ≠ a[n-i-1] THEN return false ENDIF”"
      ]
    },
    {
      "id": "component_interaction_explained",
      "dimension": "Algorithmic comprehension & decomposition",
      "description": "Explains how subcomponents (loops, functions, variables) interact to meet the overall goal.",
      "level": "A",
      "weight": 1,
      "detection_hint": "Look for phrases like “first compute prefix sums, then slide window, then compare results.” Not just listing parts.",
      "success_examples": [
        "“Outer loop moves window; inner loop updates counts; then test against threshold.”"
      ]
    },
    {
      "id": "design_linked_to_spec",
      "dimension": "Algorithm development & implementation",
      "description": "Design choices (algorithms, data structures) are explicitly justified with reference to requirements, constraints or limits.",
      "level": "M",
      "weight": 1,
      "detection_hint": "Look for reasoning like “I use BFS because we need minimal moves” or “using sorting because N is large” rather than “this solves it.”",
      "success_examples": [
        "“Because N can be up to 10⁵, I choose O(n log n) sort rather than O(n²).”"
      ]
    },
    {
      "id": "core_logic_correctly_implemented",
      "dimension": "Algorithm development & implementation",
      "description": "Core algorithmic logic (loops, conditions, data updates) is implemented correctly, with proper returns and consistency.",
      "level": "M",
      "weight": 2,
      "detection_hint": "Check loops and branches correspond to design. Missing or wrong returns, mis-updates, or broken logic result in failure.",
      "success_examples": [
        "“While left ≤ right do … adjust pointers … return final result.”"
      ]
    },
    {
      "id": "boundary_and_edge_case_handling",
      "dimension": "Algorithm development & implementation",
      "description": "Explicitly handles boundary / edge cases (empty input, minimal size, duplicates) with guard logic or special cases.",
      "level": "M",
      "weight": 1,
      "detection_hint": "Look for a separate block or comment checking extreme or degenerate inputs. Mere mention “tested edge cases” is not enough.",
      "success_examples": [
        "“If n = 0, return 0 immediately.”",
        "“When left > right break loop or return default.”"
      ]
    },
    {
      "id": "avoids_forbidden_library_shortcuts",
      "dimension": "Algorithm development & implementation",
      "description": "Does not use disallowed built-in shortcuts (e.g. reverse, sort) in improvement tasks; logic is shown explicitly.",
      "level": "M",
      "weight": 1,
      "detection_hint": "Check for absence of banned calls. If such are present in tasks where they are forbidden, this indicator fails.",
      "success_examples": [
        "“I manually compare s[i] and s[n-1-i] instead of using s.reverse().”"
      ]
    },
    {
      "id": "integration_and_coherence",
      "dimension": "Algorithm development & implementation",
      "description": "Subcomponents and optimisations are integrated into a coherent whole; all parts feed into the final solution.",
      "level": "E",
      "weight": 2,
      "detection_hint": "Look for flow across modules, no orphan code, consistent naming, and minimal redundancy. Disconnected subroutines reduce this score.",
      "success_examples": [
        "“Helper function called in main loop; no redundant code; all pathways return a result.”"
      ]
    },
    {
      "id": "correctness_and_efficiency_evaluation",
      "dimension": "Critical reflection & analysis",
      "description": "Evaluates both correctness and computational efficiency, with justified reasoning, using Big-O or metrics and comparisons.",
      "level": "E",
      "weight": 2,
      "detection_hint": "Look for statements like “This runs in O(n log n)” with reasoning or comparisons to other algorithms. Vague claims of “faster” without support are weak.",
      "success_examples": [
        "“Original was O(n²); my version is O(n log n) by replacing nested loops with sorting + two pointers.”"
      ]
    },
    {
      "id": "tradeoffs_and_implications",
      "dimension": "Critical reflection & analysis",
      "description": "Discusses trade-offs (time vs space, simplicity vs performance), limitations, and implications, comparing at least two methods.",
      "level": "E",
      "weight": 1,
      "detection_hint": "Look for explicit pros/cons and justification for chosen approach under constraints.",
      "success_examples": [
        "“Hash map is fast but more memory; tree uses less memory but slower operations.”"
      ]
    },
    {
      "id": "scalability_and_big_o_reasoning",
      "dimension": "Critical reflection & analysis",
      "description": "Explicitly reasons about how the algorithm scales with large input (e.g. doubling N) using Big-O or asymptotic thinking.",
      "level": "E",
      "weight": 1,
      "detection_hint": "Look for phrases like “if n doubles, runtime ~ quadruples”, or explicit Big-O derivations in context of constraints.",
      "success_examples": [
        "“At n = 10⁶, O(n²) is 10¹² operations — infeasible; my O(n log n) handles large N.”"
      ]
    },
    {
      "id": "insight_and_adaptation_in_new_contexts",
      "dimension": "Critical reflection & analysis",
      "description": "Adapts algorithmic reasoning to novel or variant scenarios, showing abstraction and insight beyond the base problem.",
      "level": "E",
      "weight": 1,
      "detection_hint": "Look for adjustments when constraints change (e.g. negative weights, different limits) and reasoning for why method still holds or must change.",
      "success_examples": [
        "“If weights could be negative, I would use Bellman-Ford instead of Dijkstra.”"
      ]
    },
    {
      "id": "clear_and_rhetorical_communication",
      "dimension": "Communication & presentation",
      "description": "Design steps, rationale, and reasoning are communicated clearly and convincingly, linked tightly to problem details.",
      "level": "E",
      "weight": 1,
      "detection_hint": "Look for arguments anchored in the scenario — not just abstract bullet points. Explanations should be coherent, precise, and contextual.",
      "success_examples": [
        "“I chose merge sort because in worst-case it’s O(n log n), ensuring performance on large data unlike quicksort’s possible O(n²).”"
      ]
    }
  ]
}
